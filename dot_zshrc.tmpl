# .zshrc
# インタラクティブシェルでのみ読み込まれるファイル

# 起動速度のプロファイリング
local DO_PROFILE=0

if [ "$DO_PROFILE" = true ]; then
    zmodload zsh/zprof
fi


# ================================
# env
# ================================

# eval "$(sheldon source)"

cache_dir=${XDG_CACHE_HOME:-$HOME/.cache}
sheldon_cache="$cache_dir/sheldon.zsh"
sheldon_toml="$HOME/.config/sheldon/plugins.toml"
if [[ ! -r "$sheldon_cache" || "$sheldon_toml" -nt "$sheldon_cache" ]]; then
    echo "Regenerating sheldon cache..."
    mkdir -p $cache_dir
    sheldon source > $sheldon_cache
    echo "Done. Cache file: $sheldon_cache"
fi
source "$sheldon_cache"
unset cache_dir sheldon_cache sheldon_toml


# ================================
# config
# ================================

# https://zsh.sourceforge.io/Doc/Release/Options.html

setopt auto_menu # 補完キー連打で補完候補を順に表示する
setopt complete_in_word # 単語の途中でも補完を行う
# setopt LIST_ROWS_FIRST # 補完の並び順を列優先にする
bindkey "^[[Z" reverse-menu-complete  # Shift押しながらで逆順に

export HISTSIZE=10000 # ヒストリの保存行数
export SAVEHIST=10000 # ヒストリの保存行数
setopt share_history # ヒストリをセッション間で共有
setopt hist_ignore_all_dups # ヒストリに重複を保存しない
setopt hist_reduce_blanks # 記録時に余計な空白を除去する

zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS} # 補完候補に色を付ける
zstyle ':completion:*' matcher-list "m:{a-z}={A-Z}" # 補完時に大文字小文字を区別しない
zstyle ':completion:*:default' menu select=1 # 補完候補をカーソル的にハイライト
zstyle ':completion::complete:*' use-cache true # 補完候補をキャッシュする


# ================================
# tools
# ================================

# git補完でのa-zソートを無効化
zstyle ':completion:*:git*:*' sort false
# 補完候補のgroupを有効にする
zstyle ':completion:*:descriptions' format '[%d]'
# force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
zstyle ':completion:*' menu no
# cdの補完でプレビュー
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'lsd -1 --icon=always --color=always $realpath'
# switch group using `<` and `>`
zstyle ':fzf-tab:*' switch-group '<' '>'

# ================================
# features
# ================================

# かつていたことのあるディレクトリに移動する
# https://qiita.com/kamykn/items/aa9920f07487559c0c7e
function fzf-z-search() {
    local res=$(z | sort -rn | cut -c 12- | sed "s|^$HOME|~|" | fzf --prompt="cd > " --preview 'dir={}; dir=${dir/#\~/$HOME}; lsd -1 --icon=always --color=always "$dir"' --preview-window=right:50%)
    if [ -n "$res" ]; then
        # historyに残したいのでcdで打ったことにする
        BUFFER+="cd $res"
        zle accept-line
    else
        # プロンプト消えちゃう対策
        zle redisplay
        return 1
    fi
}

zle -N fzf-z-search
bindkey '^z' fzf-z-search

# ghqで管理しているリポジトリに移動する
function fzf-ghq-search() {
    setopt local_options
    unsetopt xtrace
    
    local ghq_root=$(ghq root)
    local now=$(date +%s)
    local repo=$(ghq list | while read -r repo; do
        local mtime=$(stat -f "%m" "$ghq_root/$repo" 2>/dev/null)
        if [ -n "$mtime" ]; then
            local diff=$((now - mtime))
            local relative_time=""
            
            if [ $diff -lt 60 ]; then
                relative_time="${diff}s"
            elif [ $diff -lt 3600 ]; then
                relative_time="$((diff / 60))m"
            elif [ $diff -lt 86400 ]; then
                relative_time="$((diff / 3600))h"
            elif [ $diff -lt 2592000 ]; then
                relative_time="$((diff / 86400))d"
            else
                relative_time="$((diff / 2592000))mo"
            fi
            
            printf "%-60s\t\033[2m%5s ago\033[0m\n" "$repo" "$relative_time"
        fi
    done 2>/dev/null | fzf --prompt="repository > " --ansi \
        --delimiter '\t' \
        --with-nth 1,2 \
        --nth 1 \
        --preview "[ -f $ghq_root/{1}/README.md ] && bat --color=always --style=numbers $ghq_root/{1}/README.md || lsd -1 --icon=always --color=always $ghq_root/{1}" \
        --preview-window=right:50% | cut -f1 | sed 's/[[:space:]]*$//')
    if [ -n "$repo" ]; then
        BUFFER+="cd $ghq_root/$repo"
        zle accept-line
    else
        zle redisplay
        return 1
    fi
}

zle -N fzf-ghq-search
bindkey '^q' fzf-ghq-search

export FZF_DEFAULT_COMMAND='fd --type f'
export FZF_DEFAULT_OPTS='--height 50% --reverse --border --ansi'
export FZF_CTRL_R_OPTS='--prompt="history > " --preview="echo {} | bat --paging=never -l bash --color=always --style=plain" --preview-window=down:3:wrap'
source <(fzf --zsh)


# Ctrl+Q/Ctrl+Sを使えるようにフロー制御を無効化
stty -ixon

# for Alt + Arrow Keys
bindkey '\e[1;3C' forward-word  # Alt + Right Arrow
bindkey '\e[1;3D' backward-word # Alt + Left Arrow


# ================================
function sync_mise_node_version_with_volta() {
    # echo "sync_mise_node_version_with_volta"

    if [[ ! -f "package.json" ]] || [[ "$MISE_VOLTA_SYNC_USER_CONFIRMED" == "true" ]]; then
        return
    fi

    volta_node_version=$(jq -r '.volta.node // empty' package.json)

    if [[ -z $volta_node_version ]]; then
        return
    fi

    current_node_version=$(mise current node)

    if [[ $volta_node_version == $current_node_version ]]; then
        return
    fi

    echo "package.jsonに記載されているnodeのバージョンとmiseで管理されているnodeのバージョンが一致しません。"
    printf "volta.node:\t\t%s\n" "$volta_node_version"
    printf "mise current node:\t%s\n" "$current_node_version"

    echo "mise local node $volta_node_version を実行しますか？ [y/N]"
    read answer

    if [[ "$answer" =~ ^[Yy]$ ]]; then
        mise local node $volta_node_version
        echo "実行しました。"
    fi

    export MISE_VOLTA_SYNC_USER_CONFIRMED=true
}

# cd後フック
# function chpwd() {
#     sync_mise_node_version_with_volta
# }

# # シェル開いた時にもチェック
# sync_mise_node_version_with_volta



if [ "$DO_PROFILE" = true ]; then
  zprof
fi

# automatically added by pnpm
# pnpm
export PNPM_HOME="~/.local/share/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end

# moonbit
export PATH="$HOME/.moon/bin:$PATH"